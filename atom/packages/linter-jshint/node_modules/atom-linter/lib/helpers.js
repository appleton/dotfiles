'use strict';
'use babel';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exec = exports.assign = exports.unlinkFile = exports.writeFile = undefined;

let exec = exports.exec = function () {
  var ref = _asyncToGenerator(function* (command, args, opts, isNode) {
    const options = assign({
      env: yield _consistentEnv2.default.async(),
      stream: 'stdout',
      throwOnStdErr: true,
      timeout: 10000 // Ten seconds in ms
    }, opts);
    let timeout;

    if (isNode && options.env.OS) {
      delete options.env.OS;
    }

    return yield new Promise(function (resolve, reject) {
      const data = { stdout: [], stderr: [] };
      const handleError = function (error) {
        if (error && error.code === 'EACCES' || error && error.message && error.message.indexOf(COMMAND_NOT_RECOGNIZED_MESSAGE) !== -1) {
          const newError = new Error(`Failed to spawn command '${ command }'.` + ' Make sure it\'s a file, not a directory, and it\'s executable.');
          newError.name = 'BufferedProcessError';
          reject(newError);
        }
        reject(error);
      };
      const parameters = {
        command: command,
        args: args,
        options: options,
        stdout: function (chunk) {
          data.stdout.push(chunk);
        },
        stderr: function (chunk) {
          data.stderr.push(chunk);
        },
        exit: function () {
          clearTimeout(timeout);
          if (options.stream === 'stdout') {
            if (data.stderr.length && options.throwOnStdErr) {
              handleError(new Error(data.stderr.join('').trim()));
            } else {
              resolve(data.stdout.join('').trim());
            }
          } else if (options.stream === 'stderr') {
            resolve(data.stderr.join('').trim());
          } else {
            resolve({ stdout: data.stdout.join('').trim(), stderr: data.stderr.join('').trim() });
          }
        }
      };
      const spawnedProcess = isNode ? new BufferedNodeProcess(parameters) : new BufferedProcess(parameters);

      spawnedProcess.onWillThrowError(function (_ref) {
        let error = _ref.error;

        handleError(error);
      });

      if (options.stdin) {
        try {
          spawnedProcess.process.stdin.write(options.stdin.toString());
        } catch (_) {/* No Op */}
      }
      try {
        spawnedProcess.process.stdin.end();
      } catch (_) {/* No Op */}
      if (options.timeout !== Infinity) {
        timeout = setTimeout(function () {
          try {
            spawnedProcess.kill();
          } catch (_) {/* No Op */}
          reject(new Error('Process execution timed out'));
        }, options.timeout);
      }
    });
  });

  return function exec(_x, _x2, _x3, _x4) {
    return ref.apply(this, arguments);
  };
}();

exports.getTempDirectory = getTempDirectory;
exports.fileExists = fileExists;
exports.validateExec = validateExec;
exports.validateEditor = validateEditor;
exports.validateFind = validateFind;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _tmp = require('tmp');

var _tmp2 = _interopRequireDefault(_tmp);

var _sbPromisify = require('sb-promisify');

var _sbPromisify2 = _interopRequireDefault(_sbPromisify);

var _consistentEnv = require('consistent-env');

var _consistentEnv2 = _interopRequireDefault(_consistentEnv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

let BufferedProcess;
let BufferedNodeProcess;
try {
  const Atom = require('atom');
  BufferedProcess = Atom.BufferedProcess;
  BufferedNodeProcess = Atom.BufferedNodeProcess;
} catch (_) {
  BufferedNodeProcess = BufferedProcess = function () {
    throw new Error('Process execution is not available');
  };
}

const COMMAND_NOT_RECOGNIZED_MESSAGE = 'is not recognized as an internal or external command';
const writeFile = exports.writeFile = (0, _sbPromisify2.default)(_fs2.default.writeFile);
const unlinkFile = exports.unlinkFile = (0, _sbPromisify2.default)(_fs2.default.unlink);
const assign = exports.assign = Object.assign || function (target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
  return target;
};

function getTempDirectory(prefix) {
  return new Promise(function (resolve, reject) {
    _tmp2.default.dir({ prefix: prefix }, function (error, directory, cleanup) {
      if (error) {
        reject(error);
      } else resolve({ path: directory, cleanup: cleanup });
    });
  });
}

function fileExists(filePath) {
  return new Promise(function (resolve) {
    _fs2.default.access(filePath, _fs2.default.R_OK, function (error) {
      resolve(error === null);
    });
  });
}

function validateExec(command, args, options) {
  if (typeof command !== 'string') {
    throw new Error('Invalid or no `command` provided');
  } else if (!(args instanceof Array)) {
    throw new Error('Invalid or no `args` provided');
  } else if (typeof options !== 'object') {
    throw new Error('Invalid or no `options` provided');
  }
}

function validateEditor(editor) {
  let isEditor;
  if (typeof atom.workspace.isTextEditor === 'function') {
    // Added in Atom v1.4.0
    isEditor = atom.workspace.isTextEditor(editor);
  } else {
    isEditor = typeof editor.getText === 'function';
  }
  if (!isEditor) {
    throw new Error('Invalid TextEditor provided');
  }
}

function validateFind(directory, name) {
  if (typeof directory !== 'string') {
    throw new Error('Invalid or no `directory` provided');
  } else if (typeof name !== 'string' && !(name instanceof Array)) {
    throw new Error('Invalid or no `name` provided');
  }
}
